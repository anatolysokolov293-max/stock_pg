Ниже — практичный план внедрения под твой текущий стек (MySQL+PHP фронт, Python для бэктеста/оптимизации, backtesting.py+Optuna). Для простоты считаем, что расчёт индикаторов ты будешь делать в Python, поверх уже существующих свечей.[1][2]

***

## Шаг 1. Зафиксировать входные данные и доопределить структуру

Что есть сейчас (по описанию):
- Таблица `symbols`: тикер, имя, возможно board, ISIN и т.п.
- Таблицы `candels_1m`, `candels_5m`, `candels_15m`, `candels_30m`, `candels_4h`, `candels_1d` — история свечей за ~2 года по каждому символу.[3]
- Таблица `lot_history` — размер лота во времени по каждому символу.[3]

Что стоит добавить/уточнить:
- Гарантировать для свечей поля типа: `symbol_id`, `dt`, `open`, `high`, `low`, `close`, `volume` (желательно ещё `value`/`turnover`).[3]
- Отдельную таблицу `timeframes` с кодами ТФ для унификации (1m, 5m, 15m, 30m, 4h, 1d).
- Явный timezone и политика пропусков (выходные, праздники, pre/post‑market не на MOEX, но всё равно зафиксировать).

Результат шага:
- Формализованная схема входных данных, понятная и Python‑части, и веб‑интерфейсу.
- Документ/DDL, где чётко описано, какие поля и типы есть у `symbols`, `candels_*`, `lot_history`.

***

## Шаг 2. Описать справочник стратегий и параметров

Нужна структура, в которой «20 стратегий известных трейдеров» станут не абстрактной идеей, а формальными объектами.[4][5]

Что добавить в БД:
- Таблица `strategy_catalog`:
  - `id`
  - `code` (короткий системный код, например `SMA_TREND1`)
  - `name` (читаемое имя)
  - `description` (краткое текстовое описание)
  - `class_name` или `py_module`+`py_class` — ссылка на Python‑класс стратегии (backtesting.py `Strategy`).
- Таблица `strategy_params`:
  - `id`, `strategy_id`
  - `name` (например, `fast_period`, `slow_period`, `sl_pct`, `tp_pct`, `atr_mult`)
  - `type` (`int`, `float`, `categorical`, `bool`)
  - `default_value`
  - `min_value`, `max_value`, `step` (для Optuna/бэктеста)
  - `category_values` (JSON‑список для категориальных).

Задача с «20 стратегиями известных трейдеров»:
- выбрать реально реализуемые стратегии (SMA‑кроссовер, Donchian breakout, Turtle system, RSI‑перекупленность/перепроданность, Bollinger+MFI, ADX‑фильтр и т.п.) из книг/публичных описаний, НЕ пытаясь копировать текст один в один (уважение к авторским правам), а пересобрав логику по описаниям.[5][4]
- для каждой стратегии описать:
  - логика входа/выхода;
  - какие индикаторы нужны;
  - какие параметры подлежат оптимизации и в каких диапазонах.

Результат шага:
- БД‑справочник стратегий и их параметров.
- Технический список из ~20 стратегий с чётко определёнными правилами и параметрами.

***

## Шаг 3. Слой индикаторов и мульти‑таймфреймов

Тебе нужно договориться, где считать индикаторы: заранее в БД или «на лету» в Python. Для гибкости и работы с Optuna логичнее считать в Python (pandas + pandas_ta/TA‑Lib).[1]

Подзадачи:
- Написать Python‑модуль `indicators.py`, который:
  - принимает DataFrame OHLCV по одному символу и ТФ;
  - добавляет нужные колонки индикаторов (SMA, EMA, ATR, MFI, RSI, Bollinger, ADX и т.п.) по заданным параметрам.[6][1]
- Для мульти‑ТФ внутри одной стратегии (например, вход по 5m, фильтр по тренду на 1h) — решить:
  - либо в бэктест записывать уже объединённые (resample/merge) ряды в один DataFrame;
  - либо ограничиться в первой версии однΤФ‑стратегиями, а мульти‑ТФ сделать вторым этапом (очень советую начать с одного ТФ).

Результат шага:
- Готовая функция/модуль Python, который по запросу «символ+ТФ+параметры индикаторов» возвращает DataFrame с колонками индикаторов.
- Формальное описание, какие индикаторы нужны каждой стратегии из `strategy_catalog`.

***

## Шаг 4. Бэктест‑движок (backtesting.py) для одной стратегии

Здесь ты делаешь минимально работающий «движок» для одной стратегии, одного ТФ и одного инструмента.[1]

Подзадачи:
- Написать базовый класс‑обёртку вокруг backtesting.py, который:
  - по `symbol_id`, `timeframe`, `date_from`, `date_to` грузит свечи из MySQL;
  - преобразует их в DataFrame формата backtesting.py (`Open`, `High`, `Low`, `Close`, `Volume`, индекс‑дата).[1]
  - создаёт и запускает `Backtest(data, StrategyClass, cash=..., commission=..., exclusive_orders=...)`.
- Для каждой стратегии из справочника — реализовать Python‑класс, наследующий `Strategy`, и связать его с записью `strategy_catalog` (через `class_name`).[6][1]
- Учесть лотность: при расчёте размера позиции использовать `lot_history` для преобразования «кол‑ва лотов» в «кол‑во акций» и ограничений по минимальному шагу.[3]

Результат шага:
- Метод/функция `run_backtest(strategy_id, symbol_id, timeframe, params, window)` → возвращает словарь метрик, список сделок, equity‑кривую.
- В идеале — небольшой CLI/скрипт, которым можно руками погонять 1–2 стратегии на тестовых данных.

***

## Шаг 5. Слой оптимизации (Optuna) для одной стратегии

Теперь вокруг `run_backtest(...)` оборачивается оптимизация.[2][7]

Подзадачи:
- Написать функцию `objective(trial, strategy_id, symbol_id, timeframe, window)`:
  - из `strategy_params` достаёшь список параметров для данной стратегии и через `trial.suggest_*` генерируешь их значения;
  - вызываешь `run_backtest(...)` с этими параметрами;
  - возвращаешь целевую метрику (например, Sharpe, профит‑фактор или CAGR, возможно со штрафом за просадку).[8][2]
- Создать `study = optuna.create_study(direction="maximize")` и запускать `study.optimize(objective, n_trials=...)`.
- Протестировать на одной стратегии/одном инструменте/одном ТФ и окне (например, последние 60 торговых дней).

Результат шага:
- Рабочий модуль «оптимизации одной стратегии»: на вход — `strategy_id`, `symbol`, `timeframe`, `window`, количество `n_trials`; на выход:
  - лучшие параметры,
  - ключевые метрики,
  - список всех trial‑ов с параметрами и метриками.
- База/файл с сохранённой историей Optuna (SQLite или PostgreSQL хранилище, плюс возможность подключить Optuna Dashboard при желании).[2]

***

## Шаг 6. БД для результатов бэктеста и оптимизации

Чтобы потом строить сводный отчёт, нужен стабильный формат сохранения результатов.[4][3]

Добавить таблицы:
- `backtest_runs`:
  - `id`
  - `strategy_id`, `symbol_id`, `timeframe_id`
  - `window_start`, `window_end`
  - `params` (JSON)
  - метрики: `cagr`, `sharpe`, `max_dd`, `profit_factor`, `winrate`, `trades_count`, `exposure`, `sqn` и т.п.[1]
  - `optuna_trial_id` (если запуск внутри оптимизации) / `run_type` (single/optimized).
- `optimization_sessions`:
  - `id`
  - `strategy_id`, `symbol_id`, `timeframe_id`
  - `window_start`, `window_end`
  - `optuna_study_name`/`storage_url`
  - `target_metric`
  - `n_trials`, `status`, `best_value`.
- опционально `optimization_trials` (если не хочешь потом ходить в Optuna‑хранилище напрямую, а предпочитаешь денормализованный снимок):
  - `session_id`, `trial_number`, `params` (JSON), метрики.

Результат шага:
- Единый источник правды по всем запускам бэктеста и оптимизации, который легко читать из PHP‑фронта.
- Возможность в любой момент построить сводную таблицу без повторного прогона Python‑кода.

***

## Шаг 7. Walk‑forward‑логика (25 дней оптимизация → 7 дней «торговля»)

Здесь оборачиваешь шаги 4–5 в цикл по окнам времени.[9]

Подзадачи:
- Написать контроллер `run_walkforward(strategy_id, symbol_id, timeframe, params_config)`:
  - разбить 2 года истории на последовательные окна:
    - окно оптимизации: 25 дней (или N свечей);
    - окно форварда (out‑of‑sample): 5 торговых дней (неделя).[9]
  - для каждого окна:
    - запустить Optuna‑оптимизацию на оптимизационном окне;
    - взять лучшие параметры и прогнать чистый бэктест на форвард‑окне (без переобучения);
    - сохранить два типа `backtest_runs`: in‑sample и out‑of‑sample.
- Подумать о критериях остановки/фильтрации (например, если стратегия за последние X окон систематически убыточна, пометить её как «мертвая»).

Результат шага:
- Механизм, который имитирует твой план «каждую неделю переоптимизировать на последних 25 днях» и даёт реалистичные оценки производительности (out‑of‑sample).
- Набор записей в `optimization_sessions` и `backtest_runs`, достаточный для анализа устойчивости.

***

## Шаг 8. Сводная таблица стратегий × таймфреймов

Теперь можно делать тот отчёт, который ты описал.[10][4]

Структура отчёта (в БД он уже есть, фронт просто визуализирует):
- строки: `strategy_id`
- колонки: `timeframe_id`
- внутри ячейки:
  - выбранная основная метрика (например, `profit_factor` или `CAGR` по форвард‑окнам);
  - признак стабильности (например, медиана по окнам + количество убыточных окон).

Подзадачи на фронте (PHP/JS):
- эндпоинт `GET /report/strategies-summary?symbol=...`:
  - агрегирует по `backtest_runs` (тип `walkforward_out_of_sample` или аналогично);
  - считает агрегированные метрики per (strategy, timeframe);
  - отдаёт JSON для таблицы.
- интерфейс:
  - таблица стратегий × ТФ;
  - клик по ячейке:
    - детальный список окон walk‑forward (дата окна, метрики, график equity);
    - top‑3 наборов параметров по итогам оптимизации;
    - ссылка «открыть сделочные детали» (опционально).

Результат шага:
- Веб‑страница «Лаборатория стратегий»: визуально виден «heatmap» того, какие стратегии и ТФ показывают лучшие/стабильные результаты.
- Возможность провалиться в детали по каждой ячейке.

***

## Шаг 9. Механика массового прогона (batch‑контроллер)

Чтобы не запускать всё руками, нужен планировщик/скрипт.[11][3]

Подзадачи:
- Написать Python‑скрипт `run_batch.py`, который:
  - читает из `symbols` список активов (для теста 3 тикера);
  - читает из `strategy_catalog` список активных стратегий (флаг `enabled=1`);
  - читает из `timeframes` список ТФ;
  - для каждой комбинации вызывает либо чистую оптимизацию (fixed window), либо walk‑forward (конфигурация задаётся в настройках).
- При большом числе комбинаций — продумать параллельный запуск (multiprocessing или несколько рабочих узлов; Optuna умеет параллелизацию через общее хранилище).[2]

Результат шага:
- Одна команда (или cron‑задача), которую можно запускать ночью, чтобы получить актуальные результаты к утру.
- Регулярное пополнение таблиц `optimization_sessions` и `backtest_runs` свежими данными.

***

## Шаг 10. Калибровка метрик и отбор «боевых» стратегий

Когда всё технически работает, самое важное — решить, по каким критериям реально выбирать стратегии для торговли.[5][4]

Подзадачи:
- Эмпирически понаблюдать:
  - какие метрики лучше коррелируют с «нормально выглядящей» equity (без пилы и дикого оверфита);
  - какое минимальное число сделок нужно для доверия к результатам (например, ≥ 50–100 сделок за весь период).[12]
- В сводном отчёте добавить:
  - фильтры по минимальному количеству сделок и максимальной просадке;
  - цветовую подсветку ячеек по выбранной ключевой метрике.

Результат шага:
- Практические правила отбора стратегий/ТФ, которые можно встроить в интерфейс (фильтры, сортировка, «лист избранных стратегий»).
- Понимание, какие комбинации стратегий и таймфреймов реально стоит дальше переводить в боевой режим и/или в твой существующий торговый модуль.

***

Если хочешь, можно в следующем шаге детализировать одну конкретную стратегию из будущего справочника (например, SMA‑кроссовер с ATR‑стопом) и показать, как именно она будет выглядеть:
- запись в `strategy_catalog` и `strategy_params`;
- класс backtesting.py `Strategy`;
- кусок `objective` для Optuna.

[1](https://kernc.github.io/backtesting.py/)
[2](https://optuna.org)
[3](https://algotrading101.com/learn/build-my-own-custom-backtester-python/)
[4](https://extractalpha.com/2024/04/23/mastering-backtesting-portfolio-optimization-with-python/)
[5](https://www.quantstart.com/articles/backtesting-systematic-trading-strategies-in-python-considerations-and-open-source-frameworks/)
[6](https://www.interactivebrokers.com/campus/ibkr-quant-news/backtesting-py-an-introductory-guide-to-backtesting-with-python/)
[7](https://optuna.readthedocs.io)
[8](https://www.datacamp.com/tutorial/optuna)
[9](https://python.plainenglish.io/momentum-meets-volatility-a-data-driven-approach-to-strategy-optimization-683975dde552)
[10](https://github.com/karthikramx/Algorithmic-Trading-Backtesting-Portfolio-of-Stocks-Python)
[11](https://www.youtube.com/watch?v=M-jPTocSbjE)
[12](https://concretumgroup.com/backtest-a-profitable-trend-following-strategy-using-python/)
